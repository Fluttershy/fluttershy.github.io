{"version":3,"sources":["locria/Utils.tsx","locria/LocriaStore.ts","locria/LocriaPlayback.tsx","locria/LocriaOSMD.tsx","locria/LocriaMIDI.tsx","locria/Locria.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["groupBy","list","getKey","reduce","previous","currentItem","group","push","useLocriaStore","create","set","get","osmd","instance","connected","loaded","midi","actions","osmdUpdate","state","osmdConnect","div","console","log","OpenSheetMusicDisplay","osmdLoad","file","load","then","render","midiUpdate","midiConnect","audioContext","suspend","player","loader","waitLoad","locriaPlay","allNotes","Array","from","utils","osmdGetNotes","Object","entries","x","instrument","instrumentNotes","time","duration","notes","queueChord","destination","midiInstrumentPreset","currentTime","map","note","cursor","reset","iterator","EndReached","bpm","CurrentVoiceEntries","voice","Notes","filter","halfTone","NoteTie","Duration","RealValue","Length","ParentStaff","ParentInstrument","MidiInstrumentId","currentTimeStamp","moveToNext","index","window","instrumentInfo","variable","LocriaPlayback","osmdLoaded","s","midiLoaded","type","onClick","disabled","className","LocriaOSMD","React","current","ref","LocriaMIDI","instruments","Locria","App","Boolean","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.48979da1.chunk.js","sourcesContent":["import * as React from 'react';\n\nexport type SetStateType<T> = (state: React.SetStateAction<T>, callback?: (state: T) => void) => void;\nexport function useStateWithSetStateCallback<T>(initialState: T = null!): [T, SetStateType<T>] {\n  const [state, setState] = React.useState(initialState);\n  const callbackRef = React.useRef<(state: T) => void>();\n\n  const setStateWithCallback: SetStateType<T> = React.useCallback((state, callback) => {\n    callbackRef.current = callback;\n    setState(state);\n  }, []);\n\n  React.useEffect(() => {\n    if (callbackRef.current) {\n      callbackRef.current(state);\n      callbackRef.current = null!;\n    }\n  }, [state]);\n\n  return [state, setStateWithCallback];\n}\n\nexport const groupBy = <T, K extends keyof any>(list: T[], getKey: (item: T) => K) =>\n  list.reduce((previous, currentItem) => {\n    const group = getKey(currentItem);\n    if (!previous[group]) {\n      previous[group] = [];\n    }\n    previous[group].push(currentItem);\n    return previous;\n  }, {} as Record<K, T[]>);","import { OpenSheetMusicDisplay } from 'opensheetmusicdisplay';\nimport { player as WebAudioFontPlayer } from '../@types/webaudiofont/player';\nimport create from 'zustand'\nimport { groupBy } from './Utils';\n\nexport type IMIDISounds = {\n  audioContext: AudioContext;\n  player: WebAudioFontPlayer;\n};\n\nexport type LocriaStoreOSMD = {\n  instance: OpenSheetMusicDisplay;\n  connected: boolean;\n  loaded: boolean;\n};\n\nexport type LocriaStoreMIDI = {\n  instance: IMIDISounds;\n  connected: boolean;\n  loaded: boolean;\n};\n\nexport type LocriaStoreActions = {\n  osmdUpdate(state: Partial<LocriaStoreOSMD>): void;\n  osmdConnect(div: HTMLDivElement): void;\n  osmdLoad(file: string): void;\n  midiUpdate(state: Partial<LocriaStoreMIDI>): void;\n  midiConnect(midi: IMIDISounds): void;\n  locriaPlay(): void;\n}\n\nexport type LocriaNote = {\n  instrument: number;\n  time: number;\n  note: number;\n  duration: number;\n}\n\nexport type LocriaStoreUtils = {\n  osmdGetNotes(): Generator<LocriaNote, void, unknown>;\n  midiInstrumentPreset(index: number): any;\n};\n\nexport type LocriaStore = {\n  osmd: LocriaStoreOSMD;\n  midi: LocriaStoreMIDI;\n  actions: LocriaStoreActions;\n  utils: LocriaStoreUtils;\n};\n\nconst samplePath = 'assets/Angel_Beats_-_My_Soul_Your_Beats.xml';\n\nexport const useLocriaStore = create<LocriaStore>((set, get) => ({\n  osmd: {\n    instance: null!,\n    connected: false,\n    loaded: false\n  },\n  midi: {\n    instance: null!,\n    connected: false,\n    loaded: false\n  },\n  actions: {\n    osmdUpdate(state: Partial<LocriaStoreOSMD>) { set({ osmd: { ...get().osmd, ...state } }); },\n    osmdConnect(div: HTMLDivElement) {\n      console.log('[OSMD] attaching osmd to div', div);\n      get().actions.osmdUpdate({ instance: new OpenSheetMusicDisplay(div, {}), connected: true });\n      get().actions.osmdLoad(samplePath);\n    },\n    osmdLoad(file: string) {\n      get().osmd.instance.load(file).then(() => {\n        get().osmd.instance.render();\n        get().actions.osmdUpdate({ loaded: true });\n      });\n    },\n    midiUpdate(state: Partial<LocriaStoreMIDI>) { set({ midi: { ...get().midi, ...state } }) },\n    midiConnect(midi: IMIDISounds) {\n      if (midi.audioContext.state === 'running') {\n        midi.audioContext.suspend();\n      }\n      get().actions.midiUpdate({ instance: midi, connected: true });\n      midi.player.loader.waitLoad(() => get().actions.midiUpdate({ loaded: true }));\n    },\n    locriaPlay() {\n      const { midi: { instance: midi } } = get();\n      const allNotes = Array.from(get().utils.osmdGetNotes());\n\n      for (const [, instrumentNotes] of Object.entries(groupBy(allNotes, x => x.instrument))) {\n        for (const [, notes] of Object.entries(groupBy(instrumentNotes, x => `${x.time}-${x.duration}`))) {\n          midi.player.queueChord(\n            midi.audioContext,\n            midi.audioContext.destination,\n            get().utils.midiInstrumentPreset(notes[0].instrument),\n            midi.audioContext.currentTime + notes[0].time,\n            notes.map(x => x.note),\n            notes[0].duration,\n            0.1);\n        }\n      }\n      console.log(midi, groupBy(allNotes, x => x.instrument));\n    }\n  },\n  utils: {\n    *osmdGetNotes() {\n      const { osmd: { instance: osmd } } = get();\n      const { cursor } = osmd;\n\n      cursor.reset();\n      for (const { iterator } = cursor; !iterator.EndReached; iterator.moveToNext()) {\n        const bpm = 120;\n        for (const voice of iterator.CurrentVoiceEntries) {\n          for (const note of voice.Notes.filter(note => note !== null && note.halfTone !== 0)) {\n            if (!note.NoteTie || note.NoteTie.Notes[0] === note) {\n              const duration = (note.NoteTie ? note.NoteTie.Duration.RealValue : note.Length.RealValue) * 4 * 60 / bpm;\n              yield {\n                instrument: note.ParentStaff.ParentInstrument.MidiInstrumentId,\n                time: iterator.currentTimeStamp.RealValue * 4 * 60 / bpm,\n                note: note.halfTone + 12,\n                duration: duration\n              };\n            }\n          }\n        }\n      }\n    },\n    midiInstrumentPreset(index: number) { return (window as any)[get().midi.instance.player.loader.instrumentInfo(index).variable]; }\n  }\n}));","import * as React from 'react';\nimport { useLocriaStore } from './LocriaStore';\n\nexport const LocriaPlayback = () => {\n  const { loaded: osmdLoaded } = useLocriaStore(s => s.osmd);\n  const { loaded: midiLoaded } = useLocriaStore(s => s.midi);\n  const { locriaPlay } = useLocriaStore(s => s.actions);\n  console.log('[LocriaPlayback] render');\n\n  return (\n    <div>\n      <button type=\"button\" onClick={locriaPlay} disabled={!(osmdLoaded && midiLoaded)}>\n        <i className=\"fas fa-play\"></i>\n      </button>\n    </div>\n  );\n};","import * as React from 'react';\nimport { useLocriaStore } from './LocriaStore';\n\nexport const LocriaOSMD = () => {\n  const { osmdConnect } = useLocriaStore(s => s.actions);\n  const div = React.useRef<HTMLDivElement>(null!);\n  console.log('[LocriaOSMD] render');\n\n  React.useEffect(() => {\n    osmdConnect(div.current);\n  }, [div, osmdConnect]);\n\n  return (\n    <div ref={div}></div>\n  );\n};","import * as React from 'react';\nimport MIDISounds from 'midi-sounds-react';\nimport { useLocriaStore } from './LocriaStore';\n\nexport const LocriaMIDI = () => {\n  const { midiConnect } = useLocriaStore(s => s.actions);\n  console.log('[LocriaMIDI] render');\n\n  return (\n    <div className=\"d-none\">\n      <MIDISounds\n        ref={(ref: any) => midiConnect(ref)}\n        instruments={[0]}\n      />\n    </div>\n  );\n};","import * as React from 'react';\nimport { LocriaPlayback } from './LocriaPlayback';\nimport { LocriaOSMD } from './LocriaOSMD';\nimport { LocriaMIDI } from './LocriaMIDI';\n\nexport const Locria = () => {\n  console.log('[Locria] render');\n\n  return (\n    <React.Fragment>\n      <LocriaMIDI />\n      <React.StrictMode>\n        <LocriaPlayback />\n        <LocriaOSMD />\n      </React.StrictMode>\n    </React.Fragment>\n  );\n};","import React from 'react';\nimport { Locria } from './locria/Locria';\n\nfunction App() {\n  return (\n    <Locria />\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}