{"version":3,"sources":["locria/Utils.tsx","locria/LocriaStore.ts","locria/LocriaPlayback.tsx","locria/LocriaOSMD.tsx","locria/LocriaMIDI.tsx","locria/Locria.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["useLocriaStore","create","set","get","osmd","instance","connected","loaded","midi","envelopes","actions","osmdUpdate","state","osmdConnect","div","console","log","OpenSheetMusicDisplay","osmdLoad","file","load","then","render","cursor","show","osmdCursorNext","next","osmdCursorPrevious","currentTimeStamp","iterator","RealValue","timestampIndex","reset","midiUpdate","midiConnect","audioContext","suspend","player","loader","waitLoad","locriaPlay","allNotes","Array","from","utils","osmdGetNotes","locriaStop","resume","instrumentNotes","preset","midiInstrumentPreset","instrument","forEach","note","push","queueWaveTable","destination","currentTime","time","duration","Object","entries","list","getKey","reduce","previous","currentItem","group","groupBy","x","envelope","cancel","start","clone","EndReached","bpm","CurrentVoiceEntries","voice","Notes","filter","halfTone","NoteTie","Duration","Length","ParentStaff","ParentInstrument","MidiInstrumentId","moveToNext","index","window","instrumentInfo","variable","LocriaPlayback","osmdLoaded","s","midiLoaded","className","role","type","onClick","LocriaOSMD","React","current","ref","LocriaMIDI","instruments","Locria","App","Boolean","location","hostname","match","ReactDOM","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.0a5b1913.chunk.js","sourcesContent":["import * as React from 'react';\n\nexport type SetStateType<T> = (state: React.SetStateAction<T>, callback?: (state: T) => void) => void;\nexport function useStateWithSetStateCallback<T>(initialState: T = null!): [T, SetStateType<T>] {\n  const [state, setState] = React.useState(initialState);\n  const callbackRef = React.useRef<(state: T) => void>();\n\n  const setStateWithCallback: SetStateType<T> = React.useCallback((state, callback) => {\n    callbackRef.current = callback;\n    setState(state);\n  }, []);\n\n  React.useEffect(() => {\n    if (callbackRef.current) {\n      callbackRef.current(state);\n      callbackRef.current = null!;\n    }\n  }, [state]);\n\n  return [state, setStateWithCallback];\n}\n\nexport const groupBy = <T, K extends keyof any>(list: T[], getKey: (item: T) => K) =>\n  list.reduce((previous, currentItem) => {\n    const group = getKey(currentItem);\n    if (!previous[group]) {\n      previous[group] = [];\n    }\n    previous[group].push(currentItem);\n    return previous;\n  }, {} as Record<K, T[]>);","import { OpenSheetMusicDisplay } from 'opensheetmusicdisplay';\nimport { player as WebAudioFontPlayer, Envelope } from '../@types/webaudiofont/player';\nimport create from 'zustand'\nimport { groupBy } from './Utils';\n\nexport type IMIDISounds = {\n  audioContext: AudioContext;\n  player: WebAudioFontPlayer;\n};\n\nexport type LocriaStoreOSMD = {\n  instance: OpenSheetMusicDisplay;\n  connected: boolean;\n  loaded: boolean;\n};\n\nexport type LocriaStoreMIDI = {\n  instance: IMIDISounds;\n  connected: boolean;\n  loaded: boolean;\n  envelopes: Envelope[];\n};\n\nexport type LocriaStoreActions = {\n  osmdUpdate(state: Partial<LocriaStoreOSMD>): void;\n  osmdConnect(div: HTMLDivElement): void;\n  osmdLoad(file: string): void;\n  osmdCursorNext(): void;\n  osmdCursorPrevious(): void;\n  midiUpdate(state: Partial<LocriaStoreMIDI>): void;\n  midiConnect(midi: IMIDISounds): void;\n  locriaPlay(): void;\n  locriaStop(): void;\n}\n\nexport type LocriaNote = {\n  instrument: number;\n  time: number;\n  note: number;\n  duration: number;\n}\n\nexport type LocriaStoreUtils = {\n  osmdGetNotes(): Generator<LocriaNote, void, unknown>;\n  midiInstrumentPreset(index: number): any;\n};\n\nexport type LocriaStore = {\n  osmd: LocriaStoreOSMD;\n  midi: LocriaStoreMIDI;\n  actions: LocriaStoreActions;\n  utils: LocriaStoreUtils;\n};\n\nconst samplePath = 'assets/Angel_Beats_-_My_Soul_Your_Beats.xml';\n\nexport const useLocriaStore = create<LocriaStore>((set, get) => ({\n  osmd: {\n    instance: null!,\n    connected: false,\n    loaded: false\n  },\n  midi: {\n    instance: null!,\n    connected: false,\n    loaded: false,\n    envelopes: []\n  },\n  actions: {\n    osmdUpdate(state: Partial<LocriaStoreOSMD>) { set({ osmd: { ...get().osmd, ...state } }); },\n    osmdConnect(div: HTMLDivElement) {\n      console.log('[OSMD] attaching osmd to div', div);\n      get().actions.osmdUpdate({ instance: new OpenSheetMusicDisplay(div, {}), connected: true });\n      get().actions.osmdLoad(samplePath);\n    },\n    osmdLoad(file: string) {\n      get().osmd.instance.load(file).then(() => {\n        get().osmd.instance.render();\n        get().osmd.instance.cursor.show();\n        get().actions.osmdUpdate({ loaded: true });\n      });\n    },\n    osmdCursorNext() { get().osmd.instance.cursor.next(); },\n    osmdCursorPrevious() {\n      const { osmd: { instance: { cursor } } } = get();\n      const { iterator: { currentTimeStamp: { RealValue: currentTimeStamp } } } = cursor;\n\n      if (currentTimeStamp > 0) {\n        let timestampIndex = 0;\n\n        cursor.reset();\n        while (cursor.iterator.currentTimeStamp.RealValue !== currentTimeStamp) {\n          timestampIndex++;\n          cursor.next();\n        }\n        console.log('timestampIndex', timestampIndex);\n        timestampIndex--;\n        cursor.reset();\n        while (timestampIndex > 0) {\n          timestampIndex--;\n          cursor.next();\n        }\n      }\n    },\n    midiUpdate(state: Partial<LocriaStoreMIDI>) { set({ midi: { ...get().midi, ...state } }) },\n    midiConnect(midi: IMIDISounds) {\n      if (midi.audioContext.state === 'running') {\n        midi.audioContext.suspend();\n      }\n      get().actions.midiUpdate({ instance: midi, connected: true });\n      midi.player.loader.waitLoad(() => get().actions.midiUpdate({ loaded: true }));\n    },\n    locriaPlay() {\n      const { midi: { instance: midi } } = get();\n      const allNotes = Array.from(get().utils.osmdGetNotes());\n      const envelopes: Envelope[] = [];\n\n      get().actions.locriaStop();\n      midi.audioContext.resume();\n\n      for (const [, instrumentNotes] of Object.entries(groupBy(allNotes, x => x.instrument))) {\n        const preset = get().utils.midiInstrumentPreset(instrumentNotes[0].instrument);\n        instrumentNotes.forEach(note => {\n          envelopes.push(midi.player.queueWaveTable(\n            midi.audioContext,\n            midi.audioContext.destination,\n            preset,\n            midi.audioContext.currentTime + note.time,\n            note.note,\n            note.duration,\n            0.1\n          )!);\n        });\n      }\n      get().actions.midiUpdate({ envelopes: envelopes });\n    },\n    locriaStop() {\n      get().midi.envelopes.forEach(envelope => envelope.cancel!());\n      get().actions.midiUpdate({ envelopes: [] });\n      get().midi.instance.audioContext.suspend();\n    }\n  },\n  utils: {\n    *osmdGetNotes() {\n      const { osmd: { instance: { cursor } } } = get();\n      const start = cursor.iterator.currentTimeStamp.RealValue;\n\n      console.log('gathering notes starting at', start);\n\n      // start playing from cursor's current position\n      for (const iterator = cursor.iterator.clone(); !iterator.EndReached; iterator.moveToNext()) {\n        // skip notes up to the cursor (apparently, clone does NOT put iterator at same position)\n        if (iterator.currentTimeStamp.RealValue < start) {\n          continue;\n        }\n        //TODO: read bpm from sheet; figure out how to add to music xml file\n        const bpm = 145;\n        for (const voice of iterator.CurrentVoiceEntries) {\n          // filter out empty notes and notes which produce no sounds\n          for (const note of voice.Notes.filter(note => note !== null && note.halfTone !== 0)) {\n            // if the note is involved in a tie, we only want the first note\n            if (!note.NoteTie || note.NoteTie.Notes[0] === note) {\n              // if note is involved in a tie, use the tie's duration; otherwise, use note's duration\n              const duration = (note.NoteTie ? note.NoteTie.Duration.RealValue : note.Length.RealValue) * 4 * 60 / bpm;\n              yield {\n                instrument: note.ParentStaff.ParentInstrument.MidiInstrumentId,\n                time: (iterator.currentTimeStamp.RealValue - start) * 4 * 60 / bpm,\n                note: note.halfTone + 12,\n                duration: duration\n              };\n            }\n          }\n        }\n      }\n    },\n    midiInstrumentPreset(index: number) { return (window as any)[get().midi.instance.player.loader.instrumentInfo(index).variable]; }\n  }\n}));","import * as React from 'react';\nimport { useLocriaStore } from './LocriaStore';\n\nexport const LocriaPlayback = () => {\n  const { loaded: osmdLoaded } = useLocriaStore(s => s.osmd);\n  const { loaded: midiLoaded } = useLocriaStore(s => s.midi);\n  const { osmdCursorNext, osmdCursorPrevious, locriaPlay, locriaStop } = useLocriaStore(s => s.actions);\n  console.log('[LocriaPlayback] render');\n\n  return (\n    <div className=\"d-flex justify-content-center\">\n      {!(osmdLoaded && midiLoaded)\n        ? (\n          <div className=\"m-1\">Loading...</div>\n        ) : (\n          <div className=\"btn-toolbar m-1\" role=\"toolbar\">\n            <div className=\"btn-group btn-group-sm mr-2\">\n              <button type=\"button\" className=\"btn btn-secondary\" onClick={locriaPlay}>\n                <i className=\"fas fa-play fa-fw\"></i>\n              </button>\n              <button type=\"button\" className=\"btn btn-secondary\" onClick={locriaStop}>\n                <i className=\"fas fa-stop fa-fw\"></i>\n              </button>\n            </div>\n            <div className=\"btn-group btn-group-sm\">\n              <button type=\"button\" className=\"btn btn-secondary\" onClick={osmdCursorPrevious}>\n                <i className=\"fas fa-step-backward fa-fw\"></i>\n              </button>\n              <button type=\"button\" className=\"btn btn-secondary\" onClick={osmdCursorNext}>\n                <i className=\"fas fa-step-forward fa-fw\"></i>\n              </button>\n            </div>\n          </div>\n        )}\n    </div>\n  );\n};","import * as React from 'react';\nimport { useLocriaStore } from './LocriaStore';\n\nexport const LocriaOSMD = () => {\n  const { osmdConnect } = useLocriaStore(s => s.actions);\n  const div = React.useRef<HTMLDivElement>(null!);\n  console.log('[LocriaOSMD] render');\n\n  React.useEffect(() => {\n    osmdConnect(div.current);\n  }, [div, osmdConnect]);\n\n  return (\n    <div ref={div}></div>\n  );\n};","import * as React from 'react';\nimport MIDISounds from 'midi-sounds-react';\nimport { useLocriaStore } from './LocriaStore';\n\nexport const LocriaMIDI = () => {\n  const { midiConnect } = useLocriaStore(s => s.actions);\n  console.log('[LocriaMIDI] render');\n\n  return (\n    <div className=\"d-none\">\n      <MIDISounds\n        ref={(ref: any) => midiConnect(ref)}\n        instruments={[0]}\n      />\n    </div>\n  );\n};","import * as React from 'react';\nimport { LocriaPlayback } from './LocriaPlayback';\nimport { LocriaOSMD } from './LocriaOSMD';\nimport { LocriaMIDI } from './LocriaMIDI';\n\nexport const Locria = () => {\n  console.log('[Locria] render');\n\n  return (\n    <React.Fragment>\n      <LocriaMIDI />\n      <React.StrictMode>\n        <LocriaPlayback />\n        <LocriaOSMD />\n      </React.StrictMode>\n    </React.Fragment>\n  );\n};","import React from 'react';\nimport { Locria } from './locria/Locria';\n\nfunction App() {\n  return (\n    <Locria />\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}